Alright, I have implemented most of those changes, skipping over your CSS for rendering the books as 3D, as it didn't work, and the previous implementation of that worked much better.

Otherwise, we have implemented most of the prompts and the performance seems much better. 

However, we have introduced two issues...

1) The books are not longer proportional to their sizes, which it was doing previously by using physical dimension data from Amazon sourced via the Rainforest API

2) The books overlap one another in the new design
ChatGPT said:
Thought for 18s

Nice work getting the new engine in—those two issues are both fixable with small, surgical changes.

Below is a tight “fix pack” you can paste in. It restores true physical proportions and guarantees no overlaps (even with jitter), including on tiny mobile widths.

1) Make sizes physically proportional again

You don’t need a pre-normalisation table. Compute each book’s natural width at the target row height directly from its mm dimensions:

Natural width at height H: Wi = (width_mm / height_mm) * H

Natural spine depth at height H: Di = spine_mm * (H / height_mm)

Then row-justify with a single scale s and apply it to Wi, H, and Di.

Patch (TypeScript)
// inside your row builder, before you push a book into the current row:
const H = cfg.targetRowHeight;

// Natural (unscaled) width at H, using physical aspect ratio
const Wi = (b.phys.width_mm / b.phys.height_mm) * H;

// Natural spine depth at H
const Di = b.phys.spine_mm * (H / b.phys.height_mm);

// accumulate Wi for the row (not rounded)
row.push({ b, Wi, Di });
wsum += Wi;

// when finalising a row:
const usable = containerWidth - cfg.gutterX * (n - 1);
const s = raggedLast ? Math.min(1, usable / wsum) : (usable / wsum);

let x = 0;
for (let i = 0; i < n; i++) {
  const { b, Wi, Di } = row[i];
  const w = Wi * s;
  const h = H * s;        // every item in the row has identical h
  const d = Math.max(2, Di * s);

  // …store floats; round only when writing to styles
  out.push({ id: b.id, w, h, d, x /* temp */, /* ry/z set later */ });
  x += w + cfg.gutterX;
}


Tip: keep all layout values in floats until the final DOM write. Round only when setting CSS to prevent cumulative rounding errors that can shrink gaps.

2) Eliminate overlaps (horizontal and vertical)

Overlaps generally come from jitter that’s larger than the local free gap. Clamp each item’s horizontal jitter asymmetrically: you may move left by at most 40% of the left gap and right by 40% of the right gap. That guarantees separation even if neighbours move towards you by their own 40%—a 20% safety buffer remains.

Also make sure row waviness cannot collide vertically: keep rowWaveAmp * 2 < gutterY.

Patch (TypeScript)
// after you’ve created the row’s nominal positions (without jitter),
// compute deterministic jitter seeds:
function hash32(s: string){ let h=0x811c9dc5; for (let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,0x01000193);} return (h>>>0)||1; }
function radicalInverse(i:number, base:number){ let f=1/base, r=0; while(i>0){ r += (i%base)*f; i=Math.floor(i/base); f/=base; } return r; }
const halton = (seed:number, base:number)=> radicalInverse(seed ^ (base*0x9e3779b1) >>> 0, base);

const items = rowItems; // [{id,w,h,x,d}, …] nominal, left-to-right
for (let i = 0; i < items.length; i++) {
  const it = items[i];

  // deterministic jitter candidates
  const seed = hash32(it.id);
  const jxRaw = (halton(seed, 2) - 0.5) * (cfg.jitterX * 2);
  const ry    = (halton(seed, 3) - 0.5) * (cfg.maxTiltY * 2);
  const tz    =  halton(seed, 5)        *  cfg.maxDepth;

  // local free gaps (using nominal floats, no rounding)
  const leftGap  = i === 0 ? Infinity : (it.x - (items[i-1].x + items[i-1].w));
  const rightGap = i === items.length - 1 ? Infinity : (items[i+1].x - (it.x + it.w));

  // asymmetric clamp: use ≤40% of each gap
  const maxLeft  = isFinite(leftGap)  ? -leftGap  * 0.40 : -1e9;
  const maxRight = isFinite(rightGap) ?  rightGap * 0.40 :  1e9;
  const jx = Math.min(Math.max(jxRaw, maxLeft), maxRight);

  it.x += jx;     // apply jitter safely
  it.ry = ry;
  it.z  = tz;
}

// vertical stacking with safe waviness
const rowWaveAmp = 4;                              // px (tuneable)
if (cfg.gutterY <= rowWaveAmp * 2) {               // hard safety
  cfg.gutterY = rowWaveAmp * 2 + 2;
}
const jy = Math.sin(rowIndex * 1.3) * rowWaveAmp;
for (const it of items) it.y = yCursor + jy;
yCursor += items[0].h + cfg.gutterY;

CSS sanity checks

Ensure no margins on .book tiles: margins will defeat gap maths.

Use box-sizing: border-box; if you add borders.

If you’re still seeing “visual overlap”, it can be the drop shadow; that’s fine—it’s aesthetic, not geometric.

.book {
  margin: 0; box-sizing: border-box;
  /* keep transform-only movement */
}

3) Last-row behaviour (prevents odd scaling)

To avoid giant last rows (and the illusion of overlap), keep:

const s = raggedLast ? Math.min(1, usable / wsum) : (usable / wsum);


…and never upscale the last row beyond 1×.

4) Quick self-tests you can run

Add these asserts to a debug build after each layout:

// 1) determinism
assert(deepEqual(calc(books…), calc(books…)));

// 2) per-row non-overlap (strict)
for (const row of rows) {
  for (let i=0;i<row.length-1;i++) {
    const a=row[i], b=row[i+1];
    if (a.x + a.w > b.x) console.warn('Overlap', a.id, b.id);
  }
}

// 3) justified rows fill width (±1px, rounding tolerance)
if (!raggedLast) {
  const sum = row.reduce((s,it)=>s+it.w,0) + cfg.gutterX*(row.length-1);
  if (Math.abs(sum - containerWidth) > 1) console.warn('Row not justified');
}

// 4) vertical spacing safety
if (cfg.gutterY <= rowWaveAmp*2) console.warn('Gutter too small for waviness');

Why this fixes both problems

Proportions: using Wi = (width_mm/height_mm) * H and Di = spine_mm * (H/height_mm) preserves real-world ratios at any row height, then row-justification scales all books in that row equally.

No overlap: jitter is bounded by the local free space on each side, not a fixed pixel range—so it can never push into a neighbour even on tiny screens. Guarding gutterY against the waviness amplitude prevents vertical collisions.